{
    "LICENSE": [
        "Copyright (C) 2011-2013 University of Southampton",
        "Copyright (C) 2011-2013 Daniel Alexander Smith",
        "Copyright (C) 2011-2013 Max Van Kleek",
        "Copyright (C) 2011-2013 Nigel R. Shadbolt",
        "",
        "This program is free software: you can redistribute it and/or modify",
        "it under the terms of the GNU Affero General Public License, version 3,",
        "as published by the Free Software Foundation.",
        "",
        "This program is distributed in the hope that it will be useful,",
        "but WITHOUT ANY WARRANTY; without even the implied warranty of",
        "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
        "GNU Affero General Public License for more details.",
        "",
        "You should have received a copy of the GNU Affero General Public License",
        "along with this program.  If not, see <http://www.gnu.org/licenses/>."
    ],
    "store-updates": {
        "first-version": "20131126-FIX_DIFF_VIEW",
        "versions": {
            "20131126-FIX_DIFF_VIEW": {
                "next-version": "20140113-ADD_COMMITS",
                "sql": [
                    "CREATE OR REPLACE VIEW wb_v_diffs AS ",
                    " SELECT wb_vers_diffs.version, wb_vers_diffs.diff_type, ",
                    "    j_subject.string AS subject, j_predicate.string AS predicate, ",
                    "    j_object.string AS obj_value, wb_objects.obj_type, wb_objects.obj_lang, ",
                    "    wb_objects.obj_datatype, wb_vers_diffs.object_order",
                    "   FROM wb_vers_diffs",
                    "   LEFT JOIN wb_objects ON wb_objects.id_object = wb_vers_diffs.object",
                    "   LEFT JOIN wb_strings j_subject ON j_subject.id_string = wb_vers_diffs.subject",
                    "   LEFT JOIN wb_strings j_predicate ON j_predicate.id_string = wb_vers_diffs.predicate",
                    "   LEFT JOIN wb_strings j_object ON j_object.id_string = wb_objects.obj_value",
                    "  ORDER BY wb_vers_diffs.version, wb_vers_diffs.diff_type, j_subject.string, j_predicate.string, wb_vers_diffs.object_order, j_object.string, wb_objects.obj_type, wb_objects.obj_lang, wb_objects.obj_datatype;"
                ]
            },
            "20140113-ADD_COMMITS": {
                "next-version": "20140131-CHUNKING_LONG_STRINGS",
                "sql": [
                    "CREATE TABLE ix_commits",
                    "(",
                    "  commit_hash text NOT NULL,",
                    "  date text NOT NULL,",
                    "  server_id text NOT NULL,",
                    "  original_version integer NOT NULL,",
                    "  commit_log text NOT NULL,",
                    "  CONSTRAINT pk_commit_hash PRIMARY KEY (commit_hash)",
                    ")",
                    "WITH (",
                    "  OIDS=FALSE",
                    ");",
                    "",
                    "ALTER TABLE wb_versions ADD COLUMN commits text[] NULL;"
                ]
            },
            "20140131-CHUNKING_LONG_STRINGS": {
                "next-version": "20140202-STRINGS_INDEX_FIX",
                "sql": [
                    "ALTER TABLE wb_strings ADD COLUMN uuid text NULL;",
                    "UPDATE wb_strings SET uuid = md5(string);",
                    "ALTER TABLE wb_strings ALTER COLUMN uuid SET NOT NULL;",
                    "ALTER TABLE wb_strings ADD COLUMN chunk integer NOT NULL DEFAULT 1;",
                    "",
                    "CREATE sequence stringchunks;",
                    "",
                    "CREATE OR REPLACE FUNCTION wb_get_string_id(input_string text)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    string_result integer;",
                    "    uuid text;",
                    "    tmp_string text;",
                    "    prefix_string text;",
                    "    chunk_count integer;",
                    "    first_id integer;",
                    "BEGIN",
                    "    IF input_string IS NULL",
                    "    THEN",
                    "        RETURN NULL;",
                    "    ELSE",
                    "        LOCK TABLE wb_strings IN EXCLUSIVE MODE;",
                    "        SELECT wb_strings.id_string INTO first_id FROM wb_strings WHERE (wb_strings.string = input_string);",
                    "        IF NOT FOUND THEN",
                    "",
                    "            tmp_string := input_string;",
                    "            chunk_count := 0;",
                    "            first_id := 0;",
                    "",
                    "            SELECT 'uuid--' || val::text INTO uuid FROM nextval('stringchunks') as val;",
                    "",
                    "            LOOP",
                    "                chunk_count := chunk_count + 1;",
                    "",
                    "                IF (length(tmp_string) > 1500) THEN",
                    "                    SELECT substr(tmp_string, 0, 1500) INTO prefix_string;",
                    "                    SELECT substr(tmp_string, 1500) INTO tmp_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "                ELSE",
                    "                    SELECT tmp_string INTO prefix_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "",
                    "                    EXIT;",
                    "                END IF;",
                    "            END LOOP;",
                    "",
                    "        END IF;",
                    "        RETURN first_id;",
                    "    END IF;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;",
                    "",
                    "CREATE OR REPLACE VIEW ix_v_strings AS",
                    "SELECT MIN(id_string) as id_string, uuid, string_agg(string, '') as string, count(chunk) as chunk_count FROM (SELECT * FROM wb_strings ORDER BY id_string, uuid, chunk) AS ordered GROUP BY uuid;",
                    "",
                    "CREATE OR REPLACE VIEW wb_v_latest_triples AS ",
                    " SELECT wb_latest_vers.triple_order, j_subject.string AS subject, ",
                    "    j_predicate.string AS predicate, j_object.string AS obj_value, ",
                    "    wb_objects.obj_type, wb_objects.obj_lang, wb_objects.obj_datatype",
                    "   FROM wb_latest_vers",
                    "   JOIN wb_triples ON wb_triples.id_triple = wb_latest_vers.triple",
                    "   JOIN wb_objects ON wb_objects.id_object = wb_triples.object",
                    "   JOIN ix_v_strings j_subject ON j_subject.id_string = wb_triples.subject",
                    "   JOIN ix_v_strings j_predicate ON j_predicate.id_string = wb_triples.predicate",
                    "   JOIN ix_v_strings j_object ON j_object.id_string = wb_objects.obj_value",
                    "  ORDER BY wb_latest_vers.triple_order;",
                    "",
                    "ALTER TABLE wb_strings DROP CONSTRAINT u_string;"
                ]
            },
            "20140202-STRINGS_INDEX_FIX": {
                "next-version": "20140202-FIX_UUIDS",
                "sql": [
                    "ALTER TABLE wb_strings ADD COLUMN tmp_uuid int8 NULL;",
                    "UPDATE wb_strings SET tmp_uuid = ('x'||substr(md5(uuid),1,16))::bit(64)::bigint;",
                    "DROP VIEW wb_v_latest_triples;",
                    "DROP VIEW ix_v_strings;",
                    "ALTER TABLE wb_strings DROP COLUMN uuid;",
                    "ALTER TABLE wb_strings ADD COLUMN uuid int8 NULL;",
                    "UPDATE wb_strings SET uuid = tmp_uuid;",
                    "ALTER TABLE wb_strings DROP COLUMN tmp_uuid;",
                    "CREATE INDEX ON wb_strings (string, uuid, chunk, id_string);",
                    "CREATE INDEX ON wb_strings (id_string, uuid, chunk, string);",
                    "CREATE INDEX ON wb_strings (uuid);",
                    "CREATE OR REPLACE VIEW ix_v_strings AS",
                    "SELECT MIN(id_string) as id_string, uuid, string_agg(string, '') as string, count(chunk) as chunk_count FROM (SELECT * FROM wb_strings ORDER BY id_string, uuid, chunk) AS ordered GROUP BY uuid;",
                    "",
                    "CREATE OR REPLACE VIEW wb_v_latest_triples AS ",
                    " SELECT wb_latest_vers.triple_order, j_subject.string AS subject, ",
                    "    j_predicate.string AS predicate, j_object.string AS obj_value, ",
                    "    wb_objects.obj_type, wb_objects.obj_lang, wb_objects.obj_datatype",
                    "   FROM wb_latest_vers",
                    "   JOIN wb_triples ON wb_triples.id_triple = wb_latest_vers.triple",
                    "   JOIN wb_objects ON wb_objects.id_object = wb_triples.object",
                    "   JOIN ix_v_strings j_subject ON j_subject.id_string = wb_triples.subject",
                    "   JOIN ix_v_strings j_predicate ON j_predicate.id_string = wb_triples.predicate",
                    "   JOIN ix_v_strings j_object ON j_object.id_string = wb_objects.obj_value",
                    "  ORDER BY wb_latest_vers.triple_order;"
                ]
            },
            "20140202-FIX_UUIDS": {
                "next-version": "20140203-OPTIMISE_LONG_STRINGS",
                "sql": [
                    "CREATE OR REPLACE FUNCTION wb_get_string_id(input_string text)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    string_result integer;",
                    "    uuid bigint;",
                    "    tmp_string text;",
                    "    prefix_string text;",
                    "    chunk_count integer;",
                    "    first_id integer;",
                    "BEGIN",
                    "    IF input_string IS NULL",
                    "    THEN",
                    "        RETURN NULL;",
                    "    ELSE",
                    "        LOCK TABLE wb_strings IN EXCLUSIVE MODE;",
                    "        SELECT wb_strings.id_string INTO first_id FROM wb_strings WHERE (wb_strings.string = input_string);",
                    "        IF NOT FOUND THEN",
                    "",
                    "            tmp_string := input_string;",
                    "            chunk_count := 0;",
                    "            first_id := 0;",
                    "",
                    "            SELECT val INTO uuid FROM nextval('stringchunks') as val;",
                    "",
                    "            LOOP",
                    "                chunk_count := chunk_count + 1;",
                    "",
                    "                IF (length(tmp_string) > 1500) THEN",
                    "                    SELECT substr(tmp_string, 0, 1500) INTO prefix_string;",
                    "                    SELECT substr(tmp_string, 1500) INTO tmp_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "                ELSE",
                    "                    SELECT tmp_string INTO prefix_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "",
                    "                    EXIT;",
                    "                END IF;",
                    "            END LOOP;",
                    "",
                    "        END IF;",
                    "        RETURN first_id;",
                    "    END IF;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;"
                ]
            },
            "20140203-OPTIMISE_LONG_STRINGS": {
                "next-version": "",
                "sql": [
                    "CREATE OR REPLACE FUNCTION wb_get_string_id(input_string text)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    string_result integer;",
                    "    uuid bigint;",
                    "    tmp_string text;",
                    "    prefix_string text;",
                    "    chunk_count integer;",
                    "    first_id integer;",
                    "BEGIN",
                    "    IF input_string IS NULL",
                    "    THEN",
                    "        RETURN NULL;",
                    "    ELSE",
                    "        LOCK TABLE wb_strings IN EXCLUSIVE MODE;",
                    "",
                    "    IF (length(input_string) > 1500) THEN",
                    "         SELECT min(ordered.id_string) AS id_string, ordered.uuid, ",
                    "            string_agg(ordered.string, ''::text) AS string, ",
                    "            count(ordered.chunk) AS chunk_count",
                    "        FROM ( SELECT wb_strings.id_string, wb_strings.string, wb_strings.chunk, ",
                    "            wb_strings.uuid",
                    "            FROM wb_strings",
                    "            ORDER BY wb_strings.id_string, wb_strings.uuid, wb_strings.chunk) ordered",
                    "        GROUP BY ordered.uuid;",
                    "    ELSE",
                    "        SELECT wb_strings.id_string INTO first_id FROM wb_strings WHERE (wb_strings.string = input_string);",
                    "    END IF;",
                    "",
                    "        ",
                    "        IF NOT FOUND THEN",
                    "",
                    "            tmp_string := input_string;",
                    "            chunk_count := 0;",
                    "            first_id := 0;",
                    "",
                    "            SELECT val INTO uuid FROM nextval('stringchunks') as val;",
                    "",
                    "            LOOP",
                    "                chunk_count := chunk_count + 1;",
                    "",
                    "                IF (length(tmp_string) > 1500) THEN",
                    "                    SELECT substr(tmp_string, 0, 1500) INTO prefix_string;",
                    "                    SELECT substr(tmp_string, 1500) INTO tmp_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "                ELSE",
                    "                    SELECT tmp_string INTO prefix_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "",
                    "                    EXIT;",
                    "                END IF;",
                    "            END LOOP;",
                    "",
                    "        END IF;",
                    "        RETURN first_id;",
                    "    END IF;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;"
                ]
            }
        }
    },
    "updates": {
        "first-version": "20131013-ADD_INDX_CORE_AND_USER_METADATA",
        "versions": {
            "20131013-ADD_INDX_CORE_AND_USER_METADATA": {
                "next-version": "20131028-ADD_ACL_TABLE",
                "sql": [
                    "CREATE TABLE tbl_indx_core",
                    "(",
                    "  id_indx serial NOT NULL,",
                    "  key text NOT NULL,",
                    "  value text NOT NULL,",
                    "  CONSTRAINT pk_id_indx PRIMARY KEY (id_indx)",
                    ")",
                    "WITH (",
                    "  OIDS=FALSE",
                    ");",
                    "",
                    "ALTER TABLE tbl_users ADD COLUMN user_metadata_json text NULL;"
                ]
            },
            "20131028-ADD_ACL_TABLE": {
                "next-version": "20131031-ADD_PKI_KEY_STORAGE",
                "sql": [
                    "CREATE TABLE tbl_acl",
                    "(",
                    "  id_acl serial NOT NULL,",
                    "  database_name text NOT NULL,",
                    "  user_id integer NOT NULL,",
                    "  acl_read boolean NOT NULL,",
                    "  acl_write boolean NOT NULL,",
                    "  acl_owner boolean NOT NULL,",
                    "  acl_control boolean NOT NULL,",
                    "  CONSTRAINT pk_id_acl PRIMARY KEY (id_acl)",
                    ")",
                    "WITH (",
                    "    OIDS=FALSE",
                    ");"
                ]
            },
            "20131031-ADD_PKI_KEY_STORAGE": {
                "next-version": "20131107-ADD_ROOT_BOX",
                "sql": [
                    "ALTER TABLE tbl_users ADD COLUMN public_key_rsa text NULL;",
                    "ALTER TABLE tbl_users ADD COLUMN private_key_rsa_env text NULL;"
                ]
            },
            "20131107-ADD_ROOT_BOX": {
                "next-version": "20131112-ADD_INTERNAL_USER_TYPE-HAPPY_BIRTHDAY",
                "sql": [
                    "ALTER TABLE tbl_users ADD COLUMN root_box text NULL;"
                ]
            },
            "20131112-ADD_INTERNAL_USER_TYPE-HAPPY_BIRTHDAY": {
                "next-version": "20131119-ADD_KEYSTORE_TABLE",
                "sql": [
                    "ALTER TYPE uname_type ADD VALUE 'internal';"
                ]
            },
            "20131119-ADD_KEYSTORE_TABLE": {
                "next-version": "20131126-ALTER_BOXES_DIFF_VIEW",
                "sql": [
                    "CREATE TABLE tbl_keystore",
                    "(",
                    "  id_keystore serial NOT NULL,",
                    "  public_hash text NOT NULL,",
                    "  public_key text NOT NULL,",
                    "  private_key text NOT NULL,",
                    "  CONSTRAINT pk_id_keystore PRIMARY KEY (id_keystore)",
                    ")",
                    "WITH (",
                    "    OIDS=FALSE",
                    ");"
                ]
            },
            "20131126-ALTER_BOXES_DIFF_VIEW": {
                "next-version": "20131205-ADD_USERNAME_TO_KEYSTORE",
                "sql": [
                    "ALTER TABLE tbl_indx_core ADD COLUMN boxid text NULL;"
                ]
            },
            "20131205-ADD_USERNAME_TO_KEYSTORE": {
                "next-version": "20140103-ADD_BOX_TO_KEYSTORE",
                "sql": [
                    "ALTER TABLE tbl_keystore ADD COLUMN username text NULL;"
                ]
            },
            "20140103-ADD_BOX_TO_KEYSTORE": {
                "next-version": "20140125-ADD_TOKEN_TABLE",
                "sql": [
                    "ALTER TABLE tbl_keystore ADD COLUMN box text NULL;"
                ]
            },
            "20140125-ADD_TOKEN_TABLE": {
                "next-version": "20140125-ADD_CREATED_TO_TOKEN",
                "sql": [
                    "CREATE TABLE tbl_tokens",
                    "(",
                    "  id_token serial NOT NULL,",
                    "  token_id text NOT NULL,",
                    "  username text NOT NULL,",
                    "  password_encrypted text NOT NULL,",
                    "  boxid text NOT NULL,",
                    "  appid text NOT NULL,",
                    "  origin text NOT NULL,",
                    "  clientip text NOT NULL,",
                    "  server_id text NOT NULL,",
                    "  CONSTRAINT pk_id_token PRIMARY KEY (id_token)",
                    ")",
                    "WITH (",
                    "    OIDS=FALSE",
                    ");"
                ]
            },
            "20140125-ADD_CREATED_TO_TOKEN": {
                "next-version": "20140128-ADD_ENCPK_TABLE",
                "sql": [
                    "ALTER TABLE tbl_tokens ADD COLUMN created timestamp NOT NULL;"
                ]
            },
            "20140128-ADD_ENCPK_TABLE": {
                "next-version": "",
                "sql": [
                    "CREATE TABLE tbl_encpk",
                    "(",
                    "  id_encpk serial NOT NULL,",
                    "  hash text NOT NULL,",
                    "  encpk text NOT NULL,",
                    "  serverid text NOT NULL,",
                    "  CONSTRAINT pk_id_encpk PRIMARY KEY (id_encpk)",
                    ")",
                    "WITH (",
                    "    OIDS=FALSE",
                    ");"
                ]
            }
        }
    },
    "base": {
        "indx-schema.sql": [
            "CREATE TYPE uname_type AS ENUM ('local_owner', 'local', 'openid');",
            "",
            "CREATE TABLE tbl_users",
            "(",
            "  id_user serial NOT NULL,",
            "  username text NOT NULL,",
            "  username_type uname_type NOT NULL,",
            "  password_hash character varying(128) NOT NULL,",
            "  password_encrypted text NOT NULL,",
            "  CONSTRAINT pk_id_user PRIMARY KEY (id_user),",
            "  CONSTRAINT u_username UNIQUE (username)",
            ")",
            "WITH (",
            "  OIDS=FALSE",
            ");",
            "",
            "CREATE TYPE db_user_typ AS ENUM ('rw', 'ro');",
            "",
            "CREATE TABLE tbl_keychain",
            "(",
            "  id_key serial NOT NULL,",
            "  user_id integer NOT NULL,",
            "  db_name character varying(64) NOT NULL,",
            "  db_user character varying(64) NOT NULL,",
            "  db_user_type db_user_typ NOT NULL,",
            "  db_password_encrypted text NOT NULL,",
            "  CONSTRAINT pk_id_key PRIMARY KEY (id_key),",
            "  CONSTRAINT fk_user_id FOREIGN KEY (user_id)",
            "      REFERENCES tbl_users (id_user) MATCH SIMPLE",
            "      ON UPDATE NO ACTION ON DELETE NO ACTION",
            ")",
            "WITH (",
            "    OIDS=FALSE",
            ");"
        ]
    }

}
