{
    "LICENSE": [
        "Copyright (C) 2011-2013 University of Southampton",
        "Copyright (C) 2011-2013 Daniel Alexander Smith",
        "Copyright (C) 2011-2013 Max Van Kleek",
        "Copyright (C) 2011-2013 Nigel R. Shadbolt",
        "",
        "This program is free software: you can redistribute it and/or modify",
        "it under the terms of the GNU Affero General Public License, version 3,",
        "as published by the Free Software Foundation.",
        "",
        "This program is distributed in the hope that it will be useful,",
        "but WITHOUT ANY WARRANTY; without even the implied warranty of",
        "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
        "GNU Affero General Public License for more details.",
        "",
        "You should have received a copy of the GNU Affero General Public License",
        "along with this program.  If not, see <http://www.gnu.org/licenses/>."
    ],
    "store-updates": {
        "first-version": "20131126-FIX_DIFF_VIEW",
        "versions": {
            "20131126-FIX_DIFF_VIEW": {
                "next-version": "20140113-ADD_COMMITS",
                "sql": [
                    "CREATE OR REPLACE VIEW wb_v_diffs AS ",
                    " SELECT wb_vers_diffs.version, wb_vers_diffs.diff_type, ",
                    "    j_subject.string AS subject, j_predicate.string AS predicate, ",
                    "    j_object.string AS obj_value, wb_objects.obj_type, wb_objects.obj_lang, ",
                    "    wb_objects.obj_datatype, wb_vers_diffs.object_order",
                    "   FROM wb_vers_diffs",
                    "   LEFT JOIN wb_objects ON wb_objects.id_object = wb_vers_diffs.object",
                    "   LEFT JOIN wb_strings j_subject ON j_subject.id_string = wb_vers_diffs.subject",
                    "   LEFT JOIN wb_strings j_predicate ON j_predicate.id_string = wb_vers_diffs.predicate",
                    "   LEFT JOIN wb_strings j_object ON j_object.id_string = wb_objects.obj_value",
                    "  ORDER BY wb_vers_diffs.version, wb_vers_diffs.diff_type, j_subject.string, j_predicate.string, wb_vers_diffs.object_order, j_object.string, wb_objects.obj_type, wb_objects.obj_lang, wb_objects.obj_datatype;"
                ]
            },
            "20140113-ADD_COMMITS": {
                "next-version": "20140131-CHUNKING_LONG_STRINGS",
                "sql": [
                    "CREATE TABLE ix_commits",
                    "(",
                    "  commit_hash text NOT NULL,",
                    "  date text NOT NULL,",
                    "  server_id text NOT NULL,",
                    "  original_version integer NOT NULL,",
                    "  commit_log text NOT NULL,",
                    "  CONSTRAINT pk_commit_hash PRIMARY KEY (commit_hash)",
                    ")",
                    "WITH (",
                    "  OIDS=FALSE",
                    ");",
                    "",
                    "ALTER TABLE wb_versions ADD COLUMN commits text[] NULL;"
                ]
            },
            "20140131-CHUNKING_LONG_STRINGS": {
                "next-version": "20140202-STRINGS_INDEX_FIX",
                "sql": [
                    "ALTER TABLE wb_strings ADD COLUMN uuid text NULL;",
                    "UPDATE wb_strings SET uuid = md5(string);",
                    "ALTER TABLE wb_strings ALTER COLUMN uuid SET NOT NULL;",
                    "ALTER TABLE wb_strings ADD COLUMN chunk integer NOT NULL DEFAULT 1;",
                    "",
                    "CREATE sequence stringchunks;",
                    "",
                    "CREATE OR REPLACE FUNCTION wb_get_string_id(input_string text)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    string_result integer;",
                    "    uuid text;",
                    "    tmp_string text;",
                    "    prefix_string text;",
                    "    chunk_count integer;",
                    "    first_id integer;",
                    "BEGIN",
                    "    IF input_string IS NULL",
                    "    THEN",
                    "        RETURN NULL;",
                    "    ELSE",
                    "        LOCK TABLE wb_strings IN EXCLUSIVE MODE;",
                    "        SELECT wb_strings.id_string INTO first_id FROM wb_strings WHERE (wb_strings.string = input_string);",
                    "        IF NOT FOUND THEN",
                    "",
                    "            tmp_string := input_string;",
                    "            chunk_count := 0;",
                    "            first_id := 0;",
                    "",
                    "            SELECT 'uuid--' || val::text INTO uuid FROM nextval('stringchunks') as val;",
                    "",
                    "            LOOP",
                    "                chunk_count := chunk_count + 1;",
                    "",
                    "                IF (length(tmp_string) > 1500) THEN",
                    "                    SELECT substr(tmp_string, 0, 1500) INTO prefix_string;",
                    "                    SELECT substr(tmp_string, 1500) INTO tmp_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "                ELSE",
                    "                    SELECT tmp_string INTO prefix_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "",
                    "                    EXIT;",
                    "                END IF;",
                    "            END LOOP;",
                    "",
                    "        END IF;",
                    "        RETURN first_id;",
                    "    END IF;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;",
                    "",
                    "CREATE OR REPLACE VIEW ix_v_strings AS",
                    "SELECT MIN(id_string) as id_string, uuid, string_agg(string, '') as string, count(chunk) as chunk_count FROM (SELECT * FROM wb_strings ORDER BY id_string, uuid, chunk) AS ordered GROUP BY uuid;",
                    "",
                    "CREATE OR REPLACE VIEW wb_v_latest_triples AS ",
                    " SELECT wb_latest_vers.triple_order, j_subject.string AS subject, ",
                    "    j_predicate.string AS predicate, j_object.string AS obj_value, ",
                    "    wb_objects.obj_type, wb_objects.obj_lang, wb_objects.obj_datatype",
                    "   FROM wb_latest_vers",
                    "   JOIN wb_triples ON wb_triples.id_triple = wb_latest_vers.triple",
                    "   JOIN wb_objects ON wb_objects.id_object = wb_triples.object",
                    "   JOIN ix_v_strings j_subject ON j_subject.id_string = wb_triples.subject",
                    "   JOIN ix_v_strings j_predicate ON j_predicate.id_string = wb_triples.predicate",
                    "   JOIN ix_v_strings j_object ON j_object.id_string = wb_objects.obj_value",
                    "  ORDER BY wb_latest_vers.triple_order;",
                    "",
                    "ALTER TABLE wb_strings DROP CONSTRAINT u_string;"
                ]
            },
            "20140202-STRINGS_INDEX_FIX": {
                "next-version": "20140202-FIX_UUIDS",
                "sql": [
                    "ALTER TABLE wb_strings ADD COLUMN tmp_uuid int8 NULL;",
                    "UPDATE wb_strings SET tmp_uuid = ('x'||substr(md5(uuid),1,16))::bit(64)::bigint;",
                    "DROP VIEW wb_v_latest_triples;",
                    "DROP VIEW ix_v_strings;",
                    "ALTER TABLE wb_strings DROP COLUMN uuid;",
                    "ALTER TABLE wb_strings ADD COLUMN uuid int8 NULL;",
                    "UPDATE wb_strings SET uuid = tmp_uuid;",
                    "ALTER TABLE wb_strings DROP COLUMN tmp_uuid;",
                    "CREATE INDEX ON wb_strings (string, uuid, chunk, id_string);",
                    "CREATE INDEX ON wb_strings (id_string, uuid, chunk, string);",
                    "CREATE INDEX ON wb_strings (uuid);",
                    "CREATE OR REPLACE VIEW ix_v_strings AS",
                    "SELECT MIN(id_string) as id_string, uuid, string_agg(string, '') as string, count(chunk) as chunk_count FROM (SELECT * FROM wb_strings ORDER BY id_string, uuid, chunk) AS ordered GROUP BY uuid;",
                    "",
                    "CREATE OR REPLACE VIEW wb_v_latest_triples AS ",
                    " SELECT wb_latest_vers.triple_order, j_subject.string AS subject, ",
                    "    j_predicate.string AS predicate, j_object.string AS obj_value, ",
                    "    wb_objects.obj_type, wb_objects.obj_lang, wb_objects.obj_datatype",
                    "   FROM wb_latest_vers",
                    "   JOIN wb_triples ON wb_triples.id_triple = wb_latest_vers.triple",
                    "   JOIN wb_objects ON wb_objects.id_object = wb_triples.object",
                    "   JOIN ix_v_strings j_subject ON j_subject.id_string = wb_triples.subject",
                    "   JOIN ix_v_strings j_predicate ON j_predicate.id_string = wb_triples.predicate",
                    "   JOIN ix_v_strings j_object ON j_object.id_string = wb_objects.obj_value",
                    "  ORDER BY wb_latest_vers.triple_order;"
                ]
            },
            "20140202-FIX_UUIDS": {
                "next-version": "20140203-OPTIMISE_LONG_STRINGS",
                "sql": [
                    "CREATE OR REPLACE FUNCTION wb_get_string_id(input_string text)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    string_result integer;",
                    "    uuid bigint;",
                    "    tmp_string text;",
                    "    prefix_string text;",
                    "    chunk_count integer;",
                    "    first_id integer;",
                    "BEGIN",
                    "    IF input_string IS NULL",
                    "    THEN",
                    "        RETURN NULL;",
                    "    ELSE",
                    "        LOCK TABLE wb_strings IN EXCLUSIVE MODE;",
                    "        SELECT wb_strings.id_string INTO first_id FROM wb_strings WHERE (wb_strings.string = input_string);",
                    "        IF NOT FOUND THEN",
                    "",
                    "            tmp_string := input_string;",
                    "            chunk_count := 0;",
                    "            first_id := 0;",
                    "",
                    "            SELECT val INTO uuid FROM nextval('stringchunks') as val;",
                    "",
                    "            LOOP",
                    "                chunk_count := chunk_count + 1;",
                    "",
                    "                IF (length(tmp_string) > 1500) THEN",
                    "                    SELECT substr(tmp_string, 0, 1500) INTO prefix_string;",
                    "                    SELECT substr(tmp_string, 1500) INTO tmp_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "                ELSE",
                    "                    SELECT tmp_string INTO prefix_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "",
                    "                    EXIT;",
                    "                END IF;",
                    "            END LOOP;",
                    "",
                    "        END IF;",
                    "        RETURN first_id;",
                    "    END IF;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;"
                ]
            },
            "20140203-OPTIMISE_LONG_STRINGS": {
                "next-version": "20140203-OPTIMISE_SHORT_STRINGS",
                "sql": [
                    "CREATE OR REPLACE FUNCTION wb_get_string_id(input_string text)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    string_result integer;",
                    "    uuid bigint;",
                    "    tmp_string text;",
                    "    prefix_string text;",
                    "    chunk_count integer;",
                    "    first_id integer;",
                    "BEGIN",
                    "    IF input_string IS NULL",
                    "    THEN",
                    "        RETURN NULL;",
                    "    ELSE",
                    "        LOCK TABLE wb_strings IN EXCLUSIVE MODE;",
                    "",
                    "    IF (length(input_string) > 1500) THEN",
                    "         SELECT min(ordered.id_string) AS id_string, ordered.uuid, ",
                    "            string_agg(ordered.string, ''::text) AS string, ",
                    "            count(ordered.chunk) AS chunk_count",
                    "        FROM ( SELECT wb_strings.id_string, wb_strings.string, wb_strings.chunk, ",
                    "            wb_strings.uuid",
                    "            FROM wb_strings",
                    "            ORDER BY wb_strings.id_string, wb_strings.uuid, wb_strings.chunk) ordered",
                    "        GROUP BY ordered.uuid;",
                    "    ELSE",
                    "        SELECT wb_strings.id_string INTO first_id FROM wb_strings WHERE (wb_strings.string = input_string);",
                    "    END IF;",
                    "",
                    "        ",
                    "        IF NOT FOUND THEN",
                    "",
                    "            tmp_string := input_string;",
                    "            chunk_count := 0;",
                    "            first_id := 0;",
                    "",
                    "            SELECT val INTO uuid FROM nextval('stringchunks') as val;",
                    "",
                    "            LOOP",
                    "                chunk_count := chunk_count + 1;",
                    "",
                    "                IF (length(tmp_string) > 1500) THEN",
                    "                    SELECT substr(tmp_string, 0, 1500) INTO prefix_string;",
                    "                    SELECT substr(tmp_string, 1500) INTO tmp_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "                ELSE",
                    "                    SELECT tmp_string INTO prefix_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "",
                    "                    EXIT;",
                    "                END IF;",
                    "            END LOOP;",
                    "",
                    "        END IF;",
                    "        RETURN first_id;",
                    "    END IF;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;"
                ]
            },
            "20140203-OPTIMISE_SHORT_STRINGS": {
                "next-version": "20140203-STRING_IDS_IN_VIEW",
                "sql": [
                    "CREATE OR REPLACE VIEW ix_v_short_strings AS ",
                    "SELECT * FROM wb_strings WHERE chunk = 1;"
                ]
            },
            "20140203-STRING_IDS_IN_VIEW": {
                "next-version": "20140203-OPTIMISE_LONG_STRINGS_AGAIN",
                "sql": [
                    "CREATE OR REPLACE VIEW wb_v_latest_triples_with_ids AS ",
                    " SELECT wb_latest_vers.triple_order, j_subject.string AS subject, ",
                    "    j_predicate.string AS predicate, j_object.string AS obj_value, ",
                    "    wb_objects.obj_type, wb_objects.obj_lang, wb_objects.obj_datatype, ",
                    "    j_subject.id_string AS id_subject, j_predicate.id_string AS id_predicate, ",
                    "    j_object.id_string AS id_obj_value",
                    "   FROM wb_latest_vers",
                    "   JOIN wb_triples ON wb_triples.id_triple = wb_latest_vers.triple",
                    "   JOIN wb_objects ON wb_objects.id_object = wb_triples.object",
                    "   JOIN ix_v_strings j_subject ON j_subject.id_string = wb_triples.subject",
                    "   JOIN ix_v_strings j_predicate ON j_predicate.id_string = wb_triples.predicate",
                    "   JOIN ix_v_strings j_object ON j_object.id_string = wb_objects.obj_value",
                    "  ORDER BY wb_latest_vers.triple_order;"
                ]
            },
            "20140203-OPTIMISE_LONG_STRINGS_AGAIN": {
                "next-version": "20140203-LONG_STRING_ASSERT_FIX",
                "sql": [
                    "CREATE OR REPLACE FUNCTION wb_get_string_id(input_string text)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    string_result integer;",
                    "    uuid bigint;",
                    "    tmp_string text;",
                    "    prefix_string text;",
                    "    chunk_count integer;",
                    "    first_id integer;",
                    "BEGIN",
                    "    IF input_string IS NULL",
                    "    THEN",
                    "        RETURN NULL;",
                    "    ELSE",
                    "        LOCK TABLE wb_strings IN EXCLUSIVE MODE;",
                    "",
                    "    IF (length(input_string) > 1500) THEN ",
                    "        SELECT theinner.inner_id INTO first_id FROM ( ",
                    "         SELECT min(ordered.id_string) AS inner_id, ordered.uuid, ",
                    "            string_agg(ordered.string, ''::text) AS string, ",
                    "            count(ordered.chunk) AS chunk_count",
                    "        FROM ( SELECT wb_strings.id_string, wb_strings.string, wb_strings.chunk, ",
                    "            wb_strings.uuid",
                    "            FROM wb_strings",
                    "            ORDER BY wb_strings.id_string, wb_strings.uuid, wb_strings.chunk) ordered",
                    "        GROUP BY ordered.uuid) AS theinner;",
                    "    ELSE",
                    "        SELECT wb_strings.id_string INTO first_id FROM wb_strings WHERE (wb_strings.string = input_string);",
                    "    END IF;",
                    "",
                    "        ",
                    "        IF NOT FOUND THEN",
                    "",
                    "            tmp_string := input_string;",
                    "            chunk_count := 0;",
                    "            first_id := 0;",
                    "",
                    "            SELECT val INTO uuid FROM nextval('stringchunks') as val;",
                    "",
                    "            LOOP",
                    "                chunk_count := chunk_count + 1;",
                    "",
                    "                IF (length(tmp_string) > 1500) THEN",
                    "                    SELECT substr(tmp_string, 0, 1500) INTO prefix_string;",
                    "                    SELECT substr(tmp_string, 1500) INTO tmp_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "                ELSE",
                    "                    SELECT tmp_string INTO prefix_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "",
                    "                    EXIT;",
                    "                END IF;",
                    "            END LOOP;",
                    "",
                    "        END IF;",
                    "        RETURN first_id;",
                    "    END IF;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;"
                ]
            },
            "20140203-LONG_STRING_ASSERT_FIX": {
                "next-version": "20140204-LONG_STRING_HANDLE_IN_PYTHON",
                "sql": [
                    "CREATE OR REPLACE FUNCTION wb_get_string_id(input_string text)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    string_result integer;",
                    "    uuid bigint;",
                    "    tmp_string text;",
                    "    prefix_string text;",
                    "    chunk_count integer;",
                    "    first_id integer;",
                    "BEGIN",
                    "    IF input_string IS NULL",
                    "    THEN",
                    "        RETURN NULL;",
                    "    ELSE",
                    "        LOCK TABLE wb_strings IN EXCLUSIVE MODE;",
                    "",
                    "    IF (length(input_string) > 1500) THEN ",
                    "        SELECT theinner.inner_id INTO first_id FROM ( ",
                    "         SELECT min(ordered.id_string) AS inner_id, ordered.uuid, ",
                    "            string_agg(ordered.string, ''::text) AS string, ",
                    "            count(ordered.chunk) AS chunk_count",
                    "        FROM ( SELECT wb_strings.id_string, wb_strings.string, wb_strings.chunk, ",
                    "            wb_strings.uuid",
                    "            FROM wb_strings WHERE (wb_strings.string = input_string)",
                    "            ORDER BY wb_strings.id_string, wb_strings.uuid, wb_strings.chunk) ordered",
                    "        GROUP BY ordered.uuid) AS theinner;",
                    "    ELSE",
                    "        SELECT wb_strings.id_string INTO first_id FROM wb_strings WHERE (wb_strings.string = input_string);",
                    "    END IF;",
                    "",
                    "        ",
                    "        IF NOT FOUND THEN",
                    "",
                    "            tmp_string := input_string;",
                    "            chunk_count := 0;",
                    "            first_id := 0;",
                    "",
                    "            SELECT val INTO uuid FROM nextval('stringchunks') as val;",
                    "",
                    "            LOOP",
                    "                chunk_count := chunk_count + 1;",
                    "",
                    "                IF (length(tmp_string) > 1500) THEN",
                    "                    SELECT substr(tmp_string, 0, 1500) INTO prefix_string;",
                    "                    SELECT substr(tmp_string, 1500) INTO tmp_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "                ELSE",
                    "                    SELECT tmp_string INTO prefix_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := string_result;",
                    "                    END IF;",
                    "",
                    "                    EXIT;",
                    "                END IF;",
                    "            END LOOP;",
                    "",
                    "        END IF;",
                    "        RETURN first_id;",
                    "    END IF;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;"
                ]
            },
            "20140204-LONG_STRING_HANDLE_IN_PYTHON": {
                "next-version": "20140204-REINDX_NEW_COLUMNS",
                "sql": [
                    "DROP VIEW wb_v_diffs;",
                    "DROP VIEW wb_v_latest_triples;",
                    "DROP VIEW wb_v_latest_triples_with_ids;",
                    "",
                    "alter table wb_objects add column obj_value_uuid bigint;",
                    "update wb_objects set obj_value_uuid = wb_strings.uuid FROM wb_strings where wb_strings.id_string = wb_objects.obj_value;",
                    "ALTER TABLE wb_objects DROP COLUMN obj_value;",
                    "",
                    "alter table wb_triples add column subject_uuid bigint;",
                    "update wb_triples set subject_uuid = wb_strings.uuid FROM wb_strings where wb_strings.id_string = wb_triples.subject;",
                    "",
                    "alter table wb_triples add column predicate_uuid bigint;",
                    "update wb_triples set predicate_uuid = wb_strings.uuid FROM wb_strings where wb_strings.id_string = wb_triples.predicate;",
                    "",
                    "alter table wb_vers_diffs add column subject_uuid bigint;",
                    "update wb_vers_diffs set subject_uuid = wb_strings.uuid FROM wb_strings where wb_strings.id_string = wb_vers_diffs.subject;",
                    "",
                    "alter table wb_vers_diffs add column predicate_uuid bigint;",
                    "update wb_vers_diffs set predicate_uuid = wb_strings.uuid FROM wb_strings where wb_strings.id_string = wb_vers_diffs.predicate;",
                    "",
                    "alter table wb_triples drop column subject;",
                    "alter table wb_triples drop column predicate;",
                    "alter table wb_vers_diffs drop column subject;",
                    "alter table wb_vers_diffs drop column predicate;",
                    "",
                    "alter table wb_latest_subjects add column subject_uuid bigint;",
                    "update wb_latest_subjects set subject_uuid = wb_strings.uuid FROM wb_strings where wb_strings.id_string = wb_latest_subjects.id_subject;",
                    "alter table wb_latest_subjects drop column id_subject;",
                    "",
                    "CREATE OR REPLACE VIEW wb_v_diffs AS ",
                    " SELECT wb_vers_diffs.version, wb_vers_diffs.diff_type, ",
                    "    j_subject.string AS subject, j_predicate.string AS predicate, ",
                    "    j_object.string AS obj_value, wb_objects.obj_type, wb_objects.obj_lang, ",
                    "    wb_objects.obj_datatype, wb_vers_diffs.object_order, j_object.uuid AS uuid, j_object.chunk AS chunk",
                    "   FROM wb_vers_diffs",
                    "   LEFT JOIN wb_objects ON wb_objects.id_object = wb_vers_diffs.object",
                    "   LEFT JOIN wb_strings j_subject ON j_subject.uuid = wb_vers_diffs.subject_uuid",
                    "   LEFT JOIN wb_strings j_predicate ON j_predicate.uuid = wb_vers_diffs.predicate_uuid",
                    "   LEFT JOIN wb_strings j_object ON j_object.uuid = wb_objects.obj_value_uuid",
                    "  ORDER BY wb_vers_diffs.version, wb_vers_diffs.diff_type, j_subject.string, j_predicate.string, wb_vers_diffs.object_order, j_object.string, wb_objects.obj_type, wb_objects.obj_lang, wb_objects.obj_datatype, j_object.uuid, j_object.chunk;",
                    "",
                    "CREATE OR REPLACE VIEW wb_v_latest_triples AS ",
                    " SELECT wb_latest_vers.triple_order, j_subject.string AS subject, ",
                    "    j_predicate.string AS predicate, j_object.string AS obj_value, ",
                    "    wb_objects.obj_type, wb_objects.obj_lang, wb_objects.obj_datatype, ",
                    "    j_object.uuid AS uuid, j_object.chunk AS chunk",
                    "   FROM wb_latest_vers",
                    "   JOIN wb_triples ON wb_triples.id_triple = wb_latest_vers.triple",
                    "   JOIN wb_objects ON wb_objects.id_object = wb_triples.object",
                    "   JOIN wb_strings j_subject ON j_subject.uuid = wb_triples.subject_uuid",
                    "   JOIN wb_strings j_predicate ON j_predicate.uuid = wb_triples.predicate_uuid",
                    "   JOIN wb_strings j_object ON j_object.uuid = wb_objects.obj_value_uuid",
                    "  ORDER BY wb_latest_vers.triple_order, j_object.uuid, j_object.chunk;",
                    "",
                    "CREATE OR REPLACE VIEW wb_v_latest_triples_with_ids AS ",
                    " SELECT wb_latest_vers.triple_order, j_subject.string AS subject, ",
                    "    j_predicate.string AS predicate, j_object.string AS obj_value, ",
                    "    wb_objects.obj_type, wb_objects.obj_lang, wb_objects.obj_datatype, ",
                    "    j_subject.uuid AS subject_uuid, j_predicate.uuid AS predicate_uuid, ",
                    "    j_object.id_string AS id_obj_value, j_object.uuid AS uuid, j_object.chunk AS chunk",
                    "   FROM wb_latest_vers",
                    "   JOIN wb_triples ON wb_triples.id_triple = wb_latest_vers.triple",
                    "   JOIN wb_objects ON wb_objects.id_object = wb_triples.object",
                    "   JOIN wb_strings j_subject ON j_subject.uuid = wb_triples.subject_uuid",
                    "   JOIN wb_strings j_predicate ON j_predicate.uuid = wb_triples.predicate_uuid",
                    "   JOIN wb_strings j_object ON j_object.uuid = wb_objects.obj_value_uuid",
                    "  ORDER BY wb_latest_vers.triple_order, j_object.uuid, j_object.chunk;",
                    "DROP FUNCTION wb_get_string_id(text);",
                    "CREATE OR REPLACE FUNCTION wb_get_string_id(input_string text)",
                    "  RETURNS bigint AS",
                    "$BODY$DECLARE",
                    "    string_result bigint;",
                    "    uuid_out bigint;",
                    "    tmp_string text;",
                    "    prefix_string text;",
                    "    chunk_count integer;",
                    "    first_id bigint;",
                    "BEGIN",
                    "    IF input_string IS NULL",
                    "    THEN",
                    "        RETURN NULL;",
                    "    ELSE",
                    "        LOCK TABLE wb_strings IN EXCLUSIVE MODE;",
                    "",
                    "    IF (length(input_string) > 1500) THEN ",
                    "        SELECT theinner.inner_id INTO first_id FROM ( ",
                    "         SELECT ordered.uuid AS inner_id, ordered.uuid, ",
                    "            string_agg(ordered.string, ''::text) AS string, ",
                    "            count(ordered.chunk) AS chunk_count",
                    "        FROM ( SELECT wb_strings.id_string, wb_strings.string, wb_strings.chunk, ",
                    "            wb_strings.uuid",
                    "            FROM wb_strings WHERE (wb_strings.string = input_string)",
                    "            ORDER BY wb_strings.id_string, wb_strings.uuid, wb_strings.chunk) ordered",
                    "        GROUP BY ordered.uuid) AS theinner;",
                    "    ELSE",
                    "        SELECT wb_strings.uuid INTO first_id FROM wb_strings WHERE (wb_strings.string = input_string);",
                    "    END IF;",
                    "        ",
                    "        IF NOT FOUND THEN",
                    "",
                    "            tmp_string := input_string;",
                    "            chunk_count := 0;",
                    "            first_id := 0;",
                    "",
                    "            SELECT val INTO uuid_out FROM nextval('stringchunks') as val;",
                    "",
                    "            LOOP",
                    "                chunk_count := chunk_count + 1;",
                    "",
                    "                IF (length(tmp_string) > 1500) THEN",
                    "                    SELECT substr(tmp_string, 0, 1500) INTO prefix_string;",
                    "                    SELECT substr(tmp_string, 1500) INTO tmp_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid_out, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := uuid_out;",
                    "                    END IF;",
                    "                ELSE",
                    "                    SELECT tmp_string INTO prefix_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid_out, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := uuid_out;",
                    "                    END IF;",
                    "",
                    "                    EXIT;",
                    "                END IF;",
                    "            END LOOP;",
                    "",
                    "        END IF;",
                    "        RETURN first_id;",
                    "    END IF;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;",
                    "DROP FUNCTION wb_get_triple_id(text, text, text, object_type, character varying, character varying);",
                    "CREATE OR REPLACE FUNCTION wb_get_triple_id(input_subject text, input_predicate text, input_object_value text, input_object_type object_type, input_object_language character varying, input_object_datatype character varying)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    subject_value_id bigint;",
                    "    predicate_value_id bigint;",
                    "    object_result integer;",
                    "    triple_result integer;",
                    "BEGIN",
                    "    SELECT * INTO subject_value_id FROM wb_get_string_id(input_subject);",
                    "    SELECT * INTO predicate_value_id FROM wb_get_string_id(input_predicate);",
                    "    SELECT * INTO object_result FROM wb_get_object_id(input_object_type, input_object_value, input_object_language, input_object_datatype);",
                    "",
                    "    SELECT wb_triples.id_triple INTO triple_result FROM wb_triples WHERE",
                    "    (wb_triples.subject_uuid = subject_value_id AND",
                    "         wb_triples.predicate_uuid = predicate_value_id AND",
                    "         wb_triples.object = object_result);",
                    "    IF NOT FOUND THEN",
                    "        INSERT INTO wb_triples (subject_uuid, predicate_uuid, object) VALUES (subject_value_id, predicate_value_id, object_result) RETURNING wb_triples.id_triple INTO triple_result;",
                    "    END IF;",
                    "    RETURN triple_result;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;",
                    "DROP FUNCTION wb_get_object_id(object_type, text, character varying, character varying);",
                    "CREATE OR REPLACE FUNCTION wb_get_object_id(input_obj_type object_type, input_obj_value text, input_obj_lang character varying, input_obj_datatype character varying)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    value_id bigint;",
                    "    object_result integer;",
                    "BEGIN",
                    "    IF input_obj_value IS NULL",
                    "    THEN",
                    "        RETURN NULL;",
                    "    ELSE",
                    "",
                    "        SELECT * INTO value_id FROM wb_get_string_id(input_obj_value);",
                    "",
                    "        LOCK TABLE wb_objects in EXCLUSIVE MODE;",
                    "        SELECT wb_objects.id_object INTO object_result FROM wb_objects WHERE (wb_objects.obj_type = input_obj_type AND wb_objects.obj_value_uuid = value_id AND wb_objects.obj_lang = input_obj_lang AND wb_objects.obj_datatype = input_obj_datatype);",
                    "        IF NOT FOUND THEN",
                    "            INSERT INTO wb_objects (obj_type, obj_value_uuid, obj_lang, obj_datatype) VALUES (input_obj_type, value_id, input_obj_lang, input_obj_datatype) RETURNING wb_objects.id_object INTO object_result;",
                    "        END IF;",
                    "        RETURN object_result;",
                    "    END IF;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;",
                    ""
                ]
            },
            "20140204-REINDX_NEW_COLUMNS": {
                "next-version": "20140204-FIX_TABLE_ISSUES",
                "sql": [
                    "CREATE INDEX ON wb_objects (obj_value_uuid);",
                    "CREATE INDEX ON wb_triples (subject_uuid, predicate_uuid, object);",
                    "CREATE INDEX ON wb_triples (object, predicate_uuid, subject_uuid);",
                    "CREATE INDEX ON wb_triples (predicate_uuid, object);"
                ]
            },
            "20140204-FIX_TABLE_ISSUES": {
                "next-version": "20140204-FIX_FUNCTION_REF",
                "sql": [
                    "DROP FUNCTION wb_get_string_ids(text[]);",
                    "CREATE OR REPLACE FUNCTION wb_get_string_ids(input_strings text[])",
                    "  RETURNS bigint[] AS",
                    "$BODY$DECLARE",
                    "    results_ids bigint[];",
                    "    i integer;",
                    "    input_string text;",
                    "    string_id bigint;",
                    "BEGIN",
                    "    results_ids := '{}';",
                    "    IF array_length(input_strings,1) > 0 THEN",
                    "        FOR i IN 1 .. array_upper(input_strings, 1) LOOP",
                    "            input_string := input_strings[i];",
                    "            SELECT * INTO string_id FROM wb_get_string_id(input_string);",
                    "            results_ids := array_append(results_ids, string_id);",
                    "        END LOOP;",
                    "    END IF;",
                    "    RETURN results_ids;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;",
                    "",
                    "DROP FUNCTION wb_get_string_id(text);",
                    "CREATE OR REPLACE FUNCTION wb_get_string_id(input_string text)",
                    "  RETURNS bigint AS",
                    "$BODY$DECLARE",
                    "    string_result bigint;",
                    "    uuid_out bigint;",
                    "    tmp_string text;",
                    "    prefix_string text;",
                    "    chunk_count integer;",
                    "    first_id bigint;",
                    "BEGIN",
                    "    IF input_string IS NULL",
                    "    THEN",
                    "        RETURN NULL;",
                    "    ELSE",
                    "        LOCK TABLE wb_strings IN EXCLUSIVE MODE;",
                    "",
                    "    IF (length(input_string) > 1500) THEN ",
                    "        SELECT theinner.inner_id INTO first_id FROM ( ",
                    "         SELECT ordered.uuid AS inner_id, ordered.uuid, ",
                    "            string_agg(ordered.string, ''::text) AS string, ",
                    "            count(ordered.chunk) AS chunk_count",
                    "        FROM ( SELECT wb_strings.id_string, wb_strings.string, wb_strings.chunk, ",
                    "            wb_strings.uuid",
                    "            FROM wb_strings WHERE (wb_strings.string = input_string)",
                    "            ORDER BY wb_strings.id_string, wb_strings.uuid, wb_strings.chunk) ordered",
                    "        GROUP BY ordered.uuid) AS theinner;",
                    "    ELSE",
                    "        SELECT wb_strings.uuid INTO first_id FROM wb_strings WHERE (wb_strings.string = input_string);",
                    "    END IF;",
                    "",
                    "        ",
                    "        IF NOT FOUND THEN",
                    "",
                    "            tmp_string := input_string;",
                    "            chunk_count := 0;",
                    "            first_id := 0;",
                    "",
                    "            SELECT val INTO uuid_out FROM nextval('stringchunks') as val;",
                    "",
                    "            LOOP",
                    "                chunk_count := chunk_count + 1;",
                    "",
                    "                IF (length(tmp_string) > 1500) THEN",
                    "                    SELECT substr(tmp_string, 0, 1500) INTO prefix_string;",
                    "                    SELECT substr(tmp_string, 1500) INTO tmp_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid_out, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := uuid_out;",
                    "                    END IF;",
                    "                ELSE",
                    "                    SELECT tmp_string INTO prefix_string;",
                    "",
                    "                    INSERT INTO wb_strings (uuid, string, chunk) VALUES (uuid_out, prefix_string, chunk_count) RETURNING wb_strings.id_string INTO string_result;",
                    "",
                    "                    IF (first_id = 0) THEN",
                    "                        first_id := uuid_out;",
                    "                    END IF;",
                    "",
                    "                    EXIT;",
                    "                END IF;",
                    "            END LOOP;",
                    "",
                    "        END IF;",
                    "        RETURN first_id;",
                    "    END IF;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;",
                    "",
                    "DROP FUNCTION wb_get_triple_id(text, text, text, object_type, character varying, character varying);",
                    "CREATE OR REPLACE FUNCTION wb_get_triple_id(input_subject text, input_predicate text, input_object_value text, input_object_type object_type, input_object_language character varying, input_object_datatype character varying)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    subject_value_id integer;",
                    "    predicate_value_id integer;",
                    "    object_result integer;",
                    "    triple_result integer;",
                    "BEGIN",
                    "    SELECT * INTO subject_value_id FROM wb_get_string_id(input_subject);",
                    "    SELECT * INTO predicate_value_id FROM wb_get_string_id(input_predicate);",
                    "    SELECT * INTO object_result FROM wb_get_object_id(input_object_type, input_object_value, input_object_language, input_object_datatype);",
                    "",
                    "    SELECT wb_triples.id_triple INTO triple_result FROM wb_triples WHERE",
                    "    (wb_triples.subject = subject_value_id AND",
                    "         wb_triples.predicate = predicate_value_id AND",
                    "         wb_triples.object = object_result);",
                    "    IF NOT FOUND THEN",
                    "        INSERT INTO wb_triples (subject, predicate, object) VALUES (subject_value_id, predicate_value_id, object_result) RETURNING wb_triples.id_triple INTO triple_result;",
                    "    END IF;",
                    "    RETURN triple_result;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;"
                ]
            },
            "20140204-FIX_FUNCTION_REF": {
                "next-version": "20140219-DIFFS_ORDERED_FOR_LONG_STRINGS",
                "sql": [
                    "DROP FUNCTION wb_get_triple_id(text, text, text, object_type, character varying, character varying);",
                    "CREATE OR REPLACE FUNCTION wb_get_triple_id(input_subject text, input_predicate text, input_object_value text, input_object_type object_type, input_object_language character varying, input_object_datatype character varying)",
                    "  RETURNS integer AS",
                    "$BODY$DECLARE",
                    "    subject_value_id integer;",
                    "    predicate_value_id integer;",
                    "    object_result integer;",
                    "    triple_result integer;",
                    "BEGIN",
                    "    SELECT * INTO subject_value_id FROM wb_get_string_id(input_subject);",
                    "    SELECT * INTO predicate_value_id FROM wb_get_string_id(input_predicate);",
                    "    SELECT * INTO object_result FROM wb_get_object_id(input_object_type, input_object_value, input_object_language, input_object_datatype);",
                    "",
                    "    SELECT wb_triples.id_triple INTO triple_result FROM wb_triples WHERE",
                    "    (wb_triples.subject_uuid = subject_value_id AND",
                    "         wb_triples.predicate_uuid = predicate_value_id AND",
                    "         wb_triples.object = object_result);",
                    "    IF NOT FOUND THEN",
                    "        INSERT INTO wb_triples (subject_uuid, predicate_uuid, object) VALUES (subject_value_id, predicate_value_id, object_result) RETURNING wb_triples.id_triple INTO triple_result;",
                    "    END IF;",
                    "    RETURN triple_result;",
                    "END;$BODY$",
                    "  LANGUAGE plpgsql VOLATILE",
                    "  COST 100;"
                ]
            },
            "20140219-DIFFS_ORDERED_FOR_LONG_STRINGS": {
                "next-version": "20140509-MULTIPLE_VERSION_UPDATES",
                "sql": [
                    "CREATE OR REPLACE VIEW wb_v_diffs AS ",
                    " SELECT wb_vers_diffs.version, wb_vers_diffs.diff_type, ",
                    "    j_subject.string AS subject, j_predicate.string AS predicate, ",
                    "    j_object.string AS obj_value, wb_objects.obj_type, wb_objects.obj_lang, ",
                    "    wb_objects.obj_datatype, wb_vers_diffs.object_order, j_object.uuid, ",
                    "    j_object.chunk",
                    "   FROM wb_vers_diffs",
                    "   LEFT JOIN wb_objects ON wb_objects.id_object = wb_vers_diffs.object",
                    "   LEFT JOIN wb_strings j_subject ON j_subject.uuid = wb_vers_diffs.subject_uuid",
                    "   LEFT JOIN wb_strings j_predicate ON j_predicate.uuid = wb_vers_diffs.predicate_uuid",
                    "   LEFT JOIN wb_strings j_object ON j_object.uuid = wb_objects.obj_value_uuid",
                    "  ORDER BY wb_vers_diffs.version, wb_vers_diffs.diff_type, j_subject.string, j_predicate.string, wb_vers_diffs.object_order, j_object.uuid, j_object.chunk, j_object.string, wb_objects.obj_type, wb_objects.obj_lang, wb_objects.obj_datatype;"
                ]
            },
            "20140509-MULTIPLE_VERSION_UPDATES": {
                "next-version": "20140731-CODE_BUMP",
                "sql": [
                    "ALTER TABLE wb_versions DROP CONSTRAINT pk_version;"
                ]
            },
            "20140731-CODE_BUMP": {
                "next-version": "",
                "sql": [
                    "SELECT 1 as one;"
                ]
            }
        }
    },
    "updates": {
        "first-version": "20131013-ADD_INDX_CORE_AND_USER_METADATA",
        "versions": {
            "20131013-ADD_INDX_CORE_AND_USER_METADATA": {
                "next-version": "20131028-ADD_ACL_TABLE",
                "sql": [
                    "CREATE TABLE tbl_indx_core",
                    "(",
                    "  id_indx serial NOT NULL,",
                    "  key text NOT NULL,",
                    "  value text NOT NULL,",
                    "  CONSTRAINT pk_id_indx PRIMARY KEY (id_indx)",
                    ")",
                    "WITH (",
                    "  OIDS=FALSE",
                    ");",
                    "",
                    "ALTER TABLE tbl_users ADD COLUMN user_metadata_json text NULL;"
                ]
            },
            "20131028-ADD_ACL_TABLE": {
                "next-version": "20131031-ADD_PKI_KEY_STORAGE",
                "sql": [
                    "CREATE TABLE tbl_acl",
                    "(",
                    "  id_acl serial NOT NULL,",
                    "  database_name text NOT NULL,",
                    "  user_id integer NOT NULL,",
                    "  acl_read boolean NOT NULL,",
                    "  acl_write boolean NOT NULL,",
                    "  acl_owner boolean NOT NULL,",
                    "  acl_control boolean NOT NULL,",
                    "  CONSTRAINT pk_id_acl PRIMARY KEY (id_acl)",
                    ")",
                    "WITH (",
                    "    OIDS=FALSE",
                    ");"
                ]
            },
            "20131031-ADD_PKI_KEY_STORAGE": {
                "next-version": "20131107-ADD_ROOT_BOX",
                "sql": [
                    "ALTER TABLE tbl_users ADD COLUMN public_key_rsa text NULL;",
                    "ALTER TABLE tbl_users ADD COLUMN private_key_rsa_env text NULL;"
                ]
            },
            "20131107-ADD_ROOT_BOX": {
                "next-version": "20131112-ADD_INTERNAL_USER_TYPE-HAPPY_BIRTHDAY",
                "sql": [
                    "ALTER TABLE tbl_users ADD COLUMN root_box text NULL;"
                ]
            },
            "20131112-ADD_INTERNAL_USER_TYPE-HAPPY_BIRTHDAY": {
                "next-version": "20131119-ADD_KEYSTORE_TABLE",
                "sql": [
                    "ALTER TYPE uname_type ADD VALUE 'internal';"
                ]
            },
            "20131119-ADD_KEYSTORE_TABLE": {
                "next-version": "20131126-ALTER_BOXES_DIFF_VIEW",
                "sql": [
                    "CREATE TABLE tbl_keystore",
                    "(",
                    "  id_keystore serial NOT NULL,",
                    "  public_hash text NOT NULL,",
                    "  public_key text NOT NULL,",
                    "  private_key text NOT NULL,",
                    "  CONSTRAINT pk_id_keystore PRIMARY KEY (id_keystore)",
                    ")",
                    "WITH (",
                    "    OIDS=FALSE",
                    ");"
                ]
            },
            "20131126-ALTER_BOXES_DIFF_VIEW": {
                "next-version": "20131205-ADD_USERNAME_TO_KEYSTORE",
                "sql": [
                    "ALTER TABLE tbl_indx_core ADD COLUMN boxid text NULL;"
                ]
            },
            "20131205-ADD_USERNAME_TO_KEYSTORE": {
                "next-version": "20140103-ADD_BOX_TO_KEYSTORE",
                "sql": [
                    "ALTER TABLE tbl_keystore ADD COLUMN username text NULL;"
                ]
            },
            "20140103-ADD_BOX_TO_KEYSTORE": {
                "next-version": "20140125-ADD_TOKEN_TABLE",
                "sql": [
                    "ALTER TABLE tbl_keystore ADD COLUMN box text NULL;"
                ]
            },
            "20140125-ADD_TOKEN_TABLE": {
                "next-version": "20140125-ADD_CREATED_TO_TOKEN",
                "sql": [
                    "CREATE TABLE tbl_tokens",
                    "(",
                    "  id_token serial NOT NULL,",
                    "  token_id text NOT NULL,",
                    "  username text NOT NULL,",
                    "  password_encrypted text NOT NULL,",
                    "  boxid text NOT NULL,",
                    "  appid text NOT NULL,",
                    "  origin text NOT NULL,",
                    "  clientip text NOT NULL,",
                    "  server_id text NOT NULL,",
                    "  CONSTRAINT pk_id_token PRIMARY KEY (id_token)",
                    ")",
                    "WITH (",
                    "    OIDS=FALSE",
                    ");"
                ]
            },
            "20140125-ADD_CREATED_TO_TOKEN": {
                "next-version": "20140128-ADD_ENCPK_TABLE",
                "sql": [
                    "ALTER TABLE tbl_tokens ADD COLUMN created timestamp NOT NULL;"
                ]
            },
            "20140128-ADD_ENCPK_TABLE": {
                "next-version": "",
                "sql": [
                    "CREATE TABLE tbl_encpk",
                    "(",
                    "  id_encpk serial NOT NULL,",
                    "  hash text NOT NULL,",
                    "  encpk text NOT NULL,",
                    "  serverid text NOT NULL,",
                    "  CONSTRAINT pk_id_encpk PRIMARY KEY (id_encpk)",
                    ")",
                    "WITH (",
                    "    OIDS=FALSE",
                    ");"
                ]
            }
        }
    },
    "base": {
        "indx-schema.sql": [
            "CREATE TYPE uname_type AS ENUM ('local_owner', 'local', 'openid');",
            "",
            "CREATE TABLE tbl_users",
            "(",
            "  id_user serial NOT NULL,",
            "  username text NOT NULL,",
            "  username_type uname_type NOT NULL,",
            "  password_hash character varying(128) NOT NULL,",
            "  password_encrypted text NOT NULL,",
            "  CONSTRAINT pk_id_user PRIMARY KEY (id_user),",
            "  CONSTRAINT u_username UNIQUE (username)",
            ")",
            "WITH (",
            "  OIDS=FALSE",
            ");",
            "",
            "CREATE TYPE db_user_typ AS ENUM ('rw', 'ro');",
            "",
            "CREATE TABLE tbl_keychain",
            "(",
            "  id_key serial NOT NULL,",
            "  user_id integer NOT NULL,",
            "  db_name character varying(64) NOT NULL,",
            "  db_user character varying(64) NOT NULL,",
            "  db_user_type db_user_typ NOT NULL,",
            "  db_password_encrypted text NOT NULL,",
            "  CONSTRAINT pk_id_key PRIMARY KEY (id_key),",
            "  CONSTRAINT fk_user_id FOREIGN KEY (user_id)",
            "      REFERENCES tbl_users (id_user) MATCH SIMPLE",
            "      ON UPDATE NO ACTION ON DELETE NO ACTION",
            ")",
            "WITH (",
            "    OIDS=FALSE",
            ");"
        ]
    }

}
